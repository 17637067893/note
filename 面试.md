你好 

我叫王红旗 17年毕业 再黄淮学通信工程专业，毕业之后就再成成都云网世纪科技有限公司工作，做一些前端,移动端用JQuery + 

1 BFC IFC GFC FFC
FC 元素的渲染规则

BFC 块级规则  块级格式上下文
```
出发BFC
1 <body></body>
2 绝对定位positon的值不为 relative 和static
3 浮动
4 overflow 除了visible
```
IFC Inline 内联格式上下文
GFC 网格布局格式上下文
FFC  自适应上下文
2 元素隐藏
```
display none   
元素隐藏，位置消失 注册的事件无法点击
visibility: hidden  
元素隐藏 位置不消失 事件消失
opacity :0 
元素隐藏 位置不消失 事件不消失
```
3 不改变当前代码 更改元素样式
```
<img src="1.jpg" style="width: 300px !important" alt="">

1 <img src="1.jpg" style="width: 300px !important; max-width:300px" alt="">
2 <img src="1.jpg" style="width: 300px !important;width:300px !important" alt="">
3 js
doucment.getElementsByTagName("img"[0].setAttrbute("style","width:300px !important"))
```
##### 解决1px边框问题

```
1 媒体查询，利用设备像素比缩放，设置小数像素

.border { border: 1px solid #999 }
@media screen and (-webkit-min-device-pixel-ratio: 2) {
.border { border: 0.5px solid #999 }
}
@media screen and (-webkit-min-device-pixel-ratio: 3) {
.border { border: 0.333333px solid #999 }
}
2  伪类 + transform

```
![fc80d6df7dd94f91f075732220e7088.png](https://upload-images.jianshu.io/upload_images/16514325-76927343a4242c1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
["1","2","3","4","5"].map(parseInt)
实际运行的是  parseInt(param1,param2); 
参数一位传入的数值 ，参数二代表这是一个什么进制数  默认为10进制
["1","2","3","4"].map((item,index) => {
 return parseInt(item,index)
 parseInt('"1")
parseInt("2",'1')  一进制 传入2   结果为NaN
parseInt("3",2)   二进制传入3   结果为NaN 
})
```


Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现
```
const m = new Map();
const o = {p:"hello word"};
m.set(o,'content');
m.get(o) // content

Map 也可以接受一个数组作为参数。
const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);
m.size //2
m.has('name')  //true
m.get('name')   //张三

m.has('title');
m.get("Author")


WeakMap 只接受对象作为健明

const map = new Weakmap();
map.set(1,2) //报错
const obj = {};

map.set(obj,'666')

WeakMap  WeakSet 都是弱引用即使不删除垃圾回收机制也会删除变量
```
判断数据类型
```
Object.prototype.toString.call();
Array.isArray();
```
###### ES5、ES6定义对象区别

```
必须使用new 调用class

1 class 声明会提升但是不会初始化赋值
 const bar = new Bar()  //it`s ok
function Bar(){
this.bar = 42;
}

const foo = new Foo() // Foo is not defined;

class Foo{
constructore(){

this.foo = 42;
}

}

2 class 内部会启用严格模式
function Bar(){
baz = 42;  //it`s ok
}
const bar = new Bar();
class Foo{
  constructor(){
  foo = 42 // fo is not defined
}
}
const foo =new Foo();


3 class的所有方法都是不可枚举的


4 class 所有方法（包括静态方法和实例方法）都没有原型对象prototype,所以也没有[[construct]],
不能使用new来调用
function Bar(){
this.bar = 42;
}

Bar.prototype.print = function(){
console.log(this.bar);
}

const bar = new Bar();
const barPrint = new Bar.print()  //it`ok

class Foo{
constructor(){
this.foo = 42;
}
print(){
console.log(this.foo)
}
}

const foo = new Foo();
const fooPrint = new Foo.print();
```

##### 浏览器的渲染机制

```
1 HTML 标签生成DOM数 CSS生成CSS DOM 然后生成renderTree 然后计算节点样式 把他们渲染到页面上
```

#### OSI七层模型

![image-20210606165403854](G:\note\image\image-20210606165403854.png)

#### http

无状态

无连接

基于请求响应

明文传输

###### 报文格式

![image-20210606162632081](G:\note\image\image-20210606162632081.png)

###### 三次握手

客户端发送syn +序列号    服务端返回ACK 序号加1  + 一个序列号

![image-20210606162843012](G:\note\image\image-20210606162843012.png)

###### 四次握手

![image-20210606162920939](G:\note\image\image-20210606162920939.png)

#### https

```
https 结合对称加密+非对称加密 + CA认证+散列算法
```

![https1](G:\note\image\https1.png)

![https2](G:\note\image\https2.png)

#### UDP

知道对方的IP地址和端口号就能直接发送信息

```
1 无连接不可靠的
2 延迟低，容忍一些数据丢失
3 面向报文的
```

#### websocket

```
一次握手建立永久连接的全双工通信协议
```

```js
<!DOCTYPE HTML>
<html>
   <head>
   <meta charset="utf-8">
   <title>菜鸟教程(runoob.com)</title>
    
      <script type="text/javascript">
         function WebSocketTest()
         {
            if ("WebSocket" in window)
            {
               alert("您的浏览器支持 WebSocket!");
               
               // 打开一个 web socket
               var ws = new WebSocket("ws://localhost:9998/echo");
                
               ws.onopen = function()
               {
                  // Web Socket 已连接上，使用 send() 方法发送数据
                  ws.send("发送数据");
                  alert("数据发送中...");
               };
                
               ws.onmessage = function (evt) 
               { 
                  var received_msg = evt.data;
                  alert("数据已接收...");
               };
                
               ws.onclose = function()
               { 
                  // 关闭 websocket
                  alert("连接已关闭..."); 
               };
            }
            
            else
            {
               // 浏览器不支持 WebSocket
               alert("您的浏览器不支持 WebSocket!");
            }
         }
      </script>
        
   </head>
   <body>
   
      <div id="sse">
         <a href="javascript:WebSocketTest()">运行 WebSocket</a>
      </div>  
   </body>
</html>
```

